#include "fc_internal.h"
// 0 : is something error
// 1 : is device error
//#undef _FAT32_ASM
//#ifdef _FAT32_ASM
#if 1

__asm{
;// Generated by KBCC
;//.include "kbccmacro.asm"
.area _FindDirectory(FAT_OPEN)

__FindDirectory::
	LINK 	#3
	PUSH 	R3		;drive
	PUSH 	R4		;file(6)				
	PUSH 	R6
	PUSH 	R7

	MOV		R4, [FP+#(6)]
	
;//   unsigned int  drive = file->drive;	
	IGNDS 	#1
	MOV 	R3, [R4+#84]	
	
;//  if( file->dir_cluster == 0 )			//root directory
;//{
	MOV		R0, R4
	ADD		R0, #46
	MOV		R6, R0							;file->dir_cluster [TEMP] R6 = R4+46
	LOAD4$near$indirect 	R0, R1, R0		;//file->dir_cluster
	CMP$long$con 	R0, R1, 0
	RJMP 	IF_NE, fsfddL8

;//		if((GdrvGet_fsinfo(drive))->max_cluster_num < RESERVED_CLUSTER_16_BIT ) //fat 12/16
	PUSH	R3
	SCALL 	__GdrvGet_fsinfo
	ADD 	SP,	#2	
	MOV		R6, R1							;[TEMP] R6 = GdrvGet_fsinfo(drive)
	MOV		R0, R1
	ADD		R0, #30
	LOAD4$near$indirect 	R0, R1, R0		;max_cluster_num
	CMP$long$con 	R0, R1, 0xfff6
	RJMP 	IF_UGE, fsfddL10	
;//		{	
;//			sector = (GdrvGet_fsinfo(drive))->first_dir_sector;	
	MOV		R0, R6
	ADD		R0, #22
	LOAD4$near$indirect 	R0, R1, R0		;first_dir_sector
	RJMP 	#0, fsfddfsfddL9	
fsfddL10:
;//		}
;//		else
;//		{
;//			sector = FirstSectorInCluster(drive, 2);	
	MOV 	R1, #2
	MOV 	R0, #0
	SCALL	GET_FirstSectorInCluster
	RJMP 	#0, fsfddfsfddL9	
;//		}	
;//}	
;//#else
;//{
fsfddL8:
;//		sector = FirstSectorInCluster(drive, file->dir_cluster);
	MOV		R0, R6								;file->dir_cluster [TEMP] R6 = R4+46
	LOAD4$near$indirect 	R0, R1, R0	;file->dir_cluster
	SCALL	GET_FirstSectorInCluster	

;//}
fsfddfsfddL9:
;//if( sector == 0 )
;//   return NULL;
	MOV		R6, R0							;[TEMP] R6,R7 = sector
	MOV		R7, R1
	CMP$long$con 	R0, R1, 0
	RJMP 	IF_NE, fsfddL12	
	MOV 	R1, #0
	MOV 	R0, #0
	RJMP 	#0, fsfddL7	
	
fsfddL12:
;//if(ReadBuffer(drive, sector + file->dir_index/ENTRIES_PER_SECTOR))
;//{	
	IGNDS	#1	
	MOV 	R1, [R4+#50]						;file_index			
	SR 		R1, #4							;ENTRIES_PER_SECTOR = 16
	ADD		R7, R1							;[TEMP] R6,R7 = sector
	ADDC	R6, #0	
	PUSH	R7
	PUSH	R6	
	PUSH	R3							;drive
	SCALL 	_ReadBuffer
	ADD 	SP, #6
	CMP 	R0, #0
	RJMP 	IF_EQ, fsfddL14
	
; return INVALID_ADDRESS;        // error
	MOV 	R0, #(0x1 >> 16)
	MOV 	R1, #(0x1 & 0xFFFF)
	RJMP 	#0, fsfddL7	
;//}	
fsfddL14:

;// return (struct _directory *)gdrv[drive].buffer + (file->dir_index & (ENTRIES_PER_SECTOR-1));
	MOV 	R1, #30
	UMUL 	R1, R3								;R3 = drive
	MOVX 	R1, _gdrv
	ADD 	R7, R1	
	IGNDS 	#1
	MOV 	R6, [R7+#20]
	
	IGNDS	#1		
	MOV 	R1, [R4+#50]						;file->dir_index
	AND 	R1, #15								;ENTRIES_PER_SECTOR-1 = 15
	MOV 	R0, #0
	SL 		R1, #5
	SLOSB 	R0, #5			
	
	ADD 	R1, R6
	ADDC 	R0, #0
	
fsfddL7:
	POP 	R7
	POP 	R6
	POP		R4
	POP 	R3

	UNLINK_MACRO
	RETS

GET_FirstSectorInCluster:
	PUSH 	R1
	PUSH 	R0
	PUSH	R3
	SCALL 	_FirstSectorInCluster
	ADD 	SP,#6
	RETS
	
}
#else

int     CheckNotFAT32( int drive );
struct _directory* _FindDirectory(PxFCFILE file)
{
    unsigned long sector;
    unsigned int  drive = file->drive;
    
	if( file->dir_cluster == 0 )//root directory
	{
		if((GdrvGet_fsinfo(drive))->max_cluster_num < RESERVED_CLUSTER_16_BIT ) //fat 12/16
			sector = (GdrvGet_fsinfo(drive))->first_dir_sector;
		else
			sector = FirstSectorInCluster(drive, 2);
	}
	else
		sector = FirstSectorInCluster(drive, file->dir_cluster);

    if( sector == 0 )
        return NULL;

    if(ReadBuffer(drive, sector + file->dir_index/ENTRIES_PER_SECTOR))
        return INVALID_ADDRESS;        // error

    return (struct _directory *)gdrv[drive].buffer + (file->dir_index & (ENTRIES_PER_SECTOR-1));
}
#endif
